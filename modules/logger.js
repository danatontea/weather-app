export class Logger {
  constructor() {
    // IniÈ›ializeazÄƒ array-ul de log-uri
    this.logs = [];
    
    // ConfiguraÈ›ia logger-ului
    this.config = {
      maxLogs: 1000,           // Limita numÄƒrului de log-uri Ã®n memorie
      enableDebug: true,       // ActiveazÄƒ/dezactiveazÄƒ debug logging
      enableConsole: true,     // ActiveazÄƒ/dezactiveazÄƒ output-ul Ã®n consolÄƒ
      timestampFormat: 'HH:mm:ss.SSS' // Format pentru timestamp
    };
    
    // Nivelurile de logging cu prioritÄƒÈ›i
    this.levels = {
      DEBUG: { name: 'DEBUG', priority: 0, color: '#6B7280' },
      INFO:  { name: 'INFO',  priority: 1, color: '#3B82F6' },
      WARN:  { name: 'WARN',  priority: 2, color: '#F59E0B' },
      ERROR: { name: 'ERROR', priority: 3, color: '#EF4444' }
    };
    
    // Nivelul minim de logging (poate fi configurat)
    this.minLevel = this.levels.DEBUG;
    
    console.log('ðŸš€ Logger Service initialized');
  }

  /**
   * LogheazÄƒ mesaje de debug - pentru informaÈ›ii detaliate Ã®n timpul dezvoltÄƒrii
   * @param {string} message - Mesajul de debug
   * @param {*} data - Date opÈ›ionale pentru context
   */
  debug(message, data = null) {
    if (this.config.enableDebug && this._shouldLog(this.levels.DEBUG)) {
      this._log(this.levels.DEBUG, message, data);
    }
  }

  /**
   * LogheazÄƒ informaÈ›ii generale - pentru evenimente importante
   * @param {string} message - Mesajul informativ
   * @param {*} data - Date opÈ›ionale pentru context
   */
  info(message, data = null) {
    if (this._shouldLog(this.levels.INFO)) {
      this._log(this.levels.INFO, message, data);
    }
  }

  /**
   * LogheazÄƒ warning-uri - pentru situaÈ›ii care necesitÄƒ atenÈ›ie
   * @param {string} message - Mesajul de warning
   * @param {*} data - Date opÈ›ionale pentru context
   */
  warn(message, data = null) {
    if (this._shouldLog(this.levels.WARN)) {
      this._log(this.levels.WARN, message, data);
    }
  }

  /**
   * LogheazÄƒ erori - pentru erori È™i excepÈ›ii
   * @param {string} message - Mesajul de eroare
   * @param {Error|*} error - Obiectul de eroare sau date pentru context
   */
  error(message, error = null) {
    if (this._shouldLog(this.levels.ERROR)) {
      // Extrage stack trace dacÄƒ error este o instanÈ›Äƒ de Error
      const errorData = error instanceof Error ? {
        message: error.message,
        stack: error.stack,
        name: error.name
      } : error;
      
      this._log(this.levels.ERROR, message, errorData);
    }
  }

  /**
   * MetodÄƒ privatÄƒ pentru verificarea dacÄƒ un nivel de logging trebuie procesat
   * @param {Object} level - Nivelul de logging de verificat
   * @returns {boolean} - True dacÄƒ trebuie logat
   */
  _shouldLog(level) {
    return level.priority >= this.minLevel.priority;
  }

  /**
   * MetodÄƒ privatÄƒ pentru formatarea È™i stocarea log-urilor
   * @param {Object} level - Nivelul de logging
   * @param {string} message - Mesajul de logat
   * @param {*} data - Date opÈ›ionale
   */
  _log(level, message, data) {
    // CreeazÄƒ timestamp-ul
    const timestamp = this._formatTimestamp();
    
    // CreeazÄƒ obiectul log
    const logEntry = {
      timestamp: new Date(),
      level: level.name,
      message: message,
      data: data,
      id: this._generateLogId()
    };
    
    // AdaugÄƒ Ã®n array-ul de log-uri
    this.logs.push(logEntry);
    
    // LimiteazÄƒ numÄƒrul de log-uri Ã®n memorie
    this._limitLogs();
    
    // AfiÈ™eazÄƒ Ã®n consolÄƒ dacÄƒ este activat
    if (this.config.enableConsole) {
      this._logToConsole(level, timestamp, message, data);
    }
  }

  /**
   * FormateazÄƒ timestamp-ul pentru afiÈ™are
   * @returns {string} - Timestamp formatat
   */
  _formatTimestamp() {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    const milliseconds = now.getMilliseconds().toString().padStart(3, '0');
    
    return `${hours}:${minutes}:${seconds}.${milliseconds}`;
  }

  /**
   * GenereazÄƒ un ID unic pentru fiecare log
   * @returns {string} - ID-ul log-ului
   */
  _generateLogId() {
    return `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * LimiteazÄƒ numÄƒrul de log-uri Ã®n memorie
   */
  _limitLogs() {
    if (this.logs.length > this.config.maxLogs) {
      const excess = this.logs.length - this.config.maxLogs;
      this.logs.splice(0, excess);
    }
  }

  /**
   * AfiÈ™eazÄƒ log-ul Ã®n consolÄƒ cu formatare coloratÄƒ
   * @param {Object} level - Nivelul de logging
   * @param {string} timestamp - Timestamp-ul formatat
   * @param {string} message - Mesajul
   * @param {*} data - Date opÈ›ionale
   */
  _logToConsole(level, timestamp, message, data) {
    const formattedMessage = `[${timestamp}] [${level.name}] ${message}`;
    
    // FoloseÈ™te diferite metode de console Ã®n funcÈ›ie de nivel
    switch (level.name) {
      case 'DEBUG':
        console.debug(
          `%c${formattedMessage}`,
          `color: ${level.color}; font-weight: normal;`,
          data ? data : ''
        );
        break;
      case 'INFO':
        console.info(
          `%c${formattedMessage}`,
          `color: ${level.color}; font-weight: bold;`,
          data ? data : ''
        );
        break;
      case 'WARN':
        console.warn(
          `%c${formattedMessage}`,
          `color: ${level.color}; font-weight: bold;`,
          data ? data : ''
        );
        break;
      case 'ERROR':
        console.error(
          `%c${formattedMessage}`,
          `color: ${level.color}; font-weight: bold;`,
          data ? data : ''
        );
        break;
    }
  }

  /**
   * ReturneazÄƒ toate log-urile stocate
   * @returns {Array} - Array-ul cu toate log-urile
   */
  getLogs() {
    return [...this.logs]; // ReturneazÄƒ o copie pentru a evita modificÄƒrile externe
  }

  /**
   * ReturneazÄƒ log-urile filtrate dupÄƒ nivel
   * @param {string} level - Nivelul pentru filtrare (DEBUG, INFO, WARN, ERROR)
   * @returns {Array} - Array-ul cu log-urile filtrate
   */
  getLogsByLevel(level) {
    return this.logs.filter(log => log.level === level.toUpperCase());
  }

  /**
   * ReturneazÄƒ log-urile din ultimele N minute
   * @param {number} minutes - NumÄƒrul de minute
   * @returns {Array} - Array-ul cu log-urile recente
   */
  getRecentLogs(minutes = 10) {
    const cutoffTime = new Date(Date.now() - minutes * 60 * 1000);
    return this.logs.filter(log => log.timestamp > cutoffTime);
  }

  /**
   * È˜terge toate log-urile din memorie
   */
  clearLogs() {
    const count = this.logs.length;
    this.logs = [];
    console.log(`ðŸ§¹ Cleared ${count} log entries`);
  }

  /**
   * AfiÈ™eazÄƒ toate log-urile stocate Ã®n consolÄƒ
   */
  show() {
    console.group('ðŸ“‹ All Stored Logs');
    
    if (this.logs.length === 0) {
      console.log('No logs available');
    } else {
      this.logs.forEach((log, index) => {
        const level = this.levels[log.level];
        const timestamp = this._formatTimestamp();
        console.log(
          `%c[${log.timestamp.toLocaleTimeString()}] [${log.level}] ${log.message}`,
          `color: ${level.color}; font-weight: ${log.level === 'DEBUG' ? 'normal' : 'bold'};`,
          log.data ? log.data : ''
        );
      });
    }
    
    console.groupEnd();
  }

  /**
   * ExportÄƒ log-urile ca JSON
   * @returns {string} - Log-urile Ã®n format JSON
   */
  exportLogs() {
    return JSON.stringify(this.logs, null, 2);
  }

  /**
   * ConfigureazÄƒ logger-ul
   * @param {Object} options - OpÈ›iuni de configurare
   */
  configure(options = {}) {
    this.config = { ...this.config, ...options };
    
    // ActualizeazÄƒ nivelul minim dacÄƒ este specificat
    if (options.minLevel && this.levels[options.minLevel.toUpperCase()]) {
      this.minLevel = this.levels[options.minLevel.toUpperCase()];
    }
    
    this.info('Logger configuration updated', this.config);
  }

  /**
   * ReturneazÄƒ statistici despre log-uri
   * @returns {Object} - Statistici detaliate
   */
  getStats() {
    const stats = {
      total: this.logs.length,
      byLevel: {},
      memoryUsage: this.logs.length / this.config.maxLogs * 100,
      oldestLog: this.logs[0]?.timestamp || null,
      newestLog: this.logs[this.logs.length - 1]?.timestamp || null
    };

    // CalculeazÄƒ statistici per nivel
    Object.keys(this.levels).forEach(level => {
      stats.byLevel[level] = this.logs.filter(log => log.level === level).length;
    });

    return stats;
  }
}

// ExportÄƒ o instanÈ›Äƒ unicÄƒ (Singleton pattern)
export const logger = new Logger();

// Expune logger-ul global pentru debugging rapid
window.logs = {
  // AfiÈ™eazÄƒ toate log-urile
  show: () => logger.show(),
  
  // È˜terge toate log-urile
  clear: () => logger.clearLogs(),
  
  // ObÈ›ine toate log-urile
  get: () => logger.getLogs(),
  
  // ObÈ›ine log-urile dupÄƒ nivel
  level: (level) => logger.getLogsByLevel(level),
  
  // ObÈ›ine log-urile recente
  recent: (minutes) => logger.getRecentLogs(minutes),
  
  // ObÈ›ine statistici
  stats: () => logger.getStats(),
  
  // ExportÄƒ log-urile
  export: () => logger.exportLogs(),
  
  // ConfigureazÄƒ logger-ul
  config: (options) => logger.configure(options),
  
  // Acces direct la metodele de logging
  debug: (msg, data) => logger.debug(msg, data),
  info: (msg, data) => logger.info(msg, data),
  warn: (msg, data) => logger.warn(msg, data),
  error: (msg, error) => logger.error(msg, error)
};

// Mesaj de iniÈ›ializare
logger.info('Logger service is ready! Use window.logs for quick access.');

// Exemplu de utilizare Ã®n comentarii:
/*
// Utilizare de bazÄƒ:
logger.debug('Debugging user interaction', { userId: 123, action: 'click' });
logger.info('User logged in successfully', { username: 'john_doe' });
logger.warn('API response time is high', { responseTime: 2500 });
logger.error('Failed to save user data', new Error('Database connection failed'));

// Utilizare prin interfaÈ›a globalÄƒ:
window.logs.info('Quick log from console');
window.logs.show();  // AfiÈ™eazÄƒ toate log-urile
window.logs.clear(); // È˜terge toate log-urile
window.logs.stats(); // ObÈ›ine statistici

// Configurare:
logger.configure({
  maxLogs: 500,
  enableDebug: false,
  minLevel: 'INFO'
});
*/